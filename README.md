# AdventOfCode-2021

I'll try to do this in Haskell ğŸ˜... wish me luck. 

 - Day 1: âœ… (why did I choose Haskell... it's gonna be a long month)
 - Day 2: âœ… (that was... surprisingly easy... I'm gonna credit that to my exceptional Haskell skillz ğŸ˜)
 - Day 3: âœ… (part 1 was quite easy.... part 2 took wayy too much time (hours)...should've read the puzzle instructions in full... GARBAGE CODE - BUT IT WORKS!)
- Day 4: âœ… (code is much better, much more readable ğŸ˜ part 1 was tough to setup every utility function and so on but it was worth it in the end - part 2 was cake ğŸ˜; the pattern I'm seeing here is: on odd days it's a nightmare, while even days are a little bit more manageable)
- Day 5: âœ… (wasn't that hard, but solutions is unoptimal - for a functional language - lots of muatations ... - still, it works)
- Day 6: âœ… (this was actually a very fun task - optimization; part 1 was easy, basically a oneliner, but part 2 needed some thought... defined a simpler/neater recursion function and used memoization (I know how to do it, but not in Haskell - THANK YOU KIND STACKOVERFLOW STRANGER! ğŸ™) and it works flawlessly, even better than expected ğŸ˜€)
- Day 7: âœ… (quite easy, similar to Day 6 - used pre-calculated memoization table for part 2 ğŸ˜)
- Day 8: âœ… (not really an elegant solution - in fact part 2 is not a 'purely functional' solution at all - but it works and it's still written in Haskell ğŸ˜)
- Day 9: âœ… (part 1 is done in a very ugly way - redone for part 2; part 2 was quite hard, because some state management was required - opted for doing recursion in sequence using do..let statements)
- Day 10: âœ… (this one was rather easy - using only simple recursion and pattern matching; luckily I did part 1 in a way taht made part 2 trivial - only a few changes relating to score calculation ğŸ˜)
- Day 11: âœ… (that was a teaser... not su much because of the algorithm, but moreso because I had to implement it in Haskell ğŸ˜‹ I did it in the end - part 2 was relatively easy, only had to change around a few conditions)
- Day 12: âœ… (first graph problem... used adjacency list to represent graph, the algorithm itself wasn't difficult; it went pretty well for dealing with graphs in Haskell for the first time - but some methods appear to be inefficient since part 2 took a few seconds to calculate)
- Day 13: âœ… (pretty straightforward; had some difficulties in part 2 with visualization so I used an online tool to see a clearer picture)