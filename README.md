# AdventOfCode-2021

I'll try to do this in Haskell ğŸ˜... wish me luck. 

 - Day 1: âœ… (why did I choose Haskell... it's gonna be a long month)
 - Day 2: âœ… (that was... surprisingly easy... I'm gonna credit that to my exceptional Haskell skillz ğŸ˜)
 - Day 3: âœ… (part 1 was quite easy.... part 2 took wayy too much time (hours)...should've read the puzzle instructions in full... GARBAGE CODE - BUT IT WORKS!)
- Day 4: âœ… (code is much better, much more readable ğŸ˜ part 1 was tough to setup every utility function and so on but it was worth it in the end - part 2 was cake ğŸ˜; the pattern I'm seeing here is: on odd days it's a nightmare, while even days are a little bit more manageable)
- Day 5: âœ… (wasn't that hard, but solutions is unoptimal - for a functional language - lots of muatations ... - still, it works)
- Day 6: âœ… (this was actually a very fun task - optimization; part 1 was easy, basically a oneliner, but part 2 needed soem thought... defined a simpler/neater recursion function and used memoization (THANK YOU KIND STACKOVERFLOW STRANGER! ğŸ™) and it works flawlessly, even better than expected ğŸ˜€)

