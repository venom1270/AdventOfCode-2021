# AdventOfCode-2021

I'll try to do this in Haskell 😎... wish me luck. 

 - Day 1: ✅ (why did I choose Haskell... it's gonna be a long month)
 - Day 2: ✅ (that was... surprisingly easy... I'm gonna credit that to my exceptional Haskell skillz 😎)
 - Day 3: ✅ (part 1 was quite easy.... part 2 took wayy too much time (hours)...should've read the puzzle instructions in full... GARBAGE CODE - BUT IT WORKS!)
- Day 4: ✅ (code is much better, much more readable 😁 part 1 was tough to setup every utility function and so on but it was worth it in the end - part 2 was cake 😎; the pattern I'm seeing here is: on odd days it's a nightmare, while even days are a little bit more manageable)
- Day 5: ✅ (wasn't that hard, but solutions is unoptimal - for a functional language - lots of muatations ... - still, it works)
- Day 6: ✅ (this was actually a very fun task - optimization; part 1 was easy, basically a oneliner, but part 2 needed some thought... defined a simpler/neater recursion function and used memoization (I know how to do it, but not in Haskell - THANK YOU KIND STACKOVERFLOW STRANGER! 🙏) and it works flawlessly, even better than expected 😀)
- Day 7: ✅ (quite easy, similar to Day 6 - used pre-calculated memoization table for part 2 😎)
- Day 8: ✅ (not really an elegant solution - in fact part 2 is not a 'purely functional' solution at all - but it works and it's still written in Haskell 😎)
- Day 9: ✅ (part 1 is done in a very ugly way - redone for part 2; part 2 was quite hard, because some state management was required - opted for doing recursion in sequence using do..let statements)
- Day 10: ✅ (this one was rather easy - using only simple recursion and pattern matching; luckily I did part 1 in a way taht made part 2 trivial - only a few changes relating to score calculation 😎)
- Day 11: ✅ (that was a teaser... not su much because of the algorithm, but moreso because I had to implement it in Haskell 😋 I did it in the end - part 2 was relatively easy, only had to change around a few conditions)
- Day 12: ✅ (first graph problem... used adjacency list to represent graph, the algorithm itself wasn't difficult; it went pretty well for dealing with graphs in Haskell for the first time - but some methods appear to be inefficient since part 2 took a few seconds to calculate)
- Day 13: ✅ (pretty straightforward; had some difficulties in part 2 with visualization so I used an online tool to see a clearer picture)